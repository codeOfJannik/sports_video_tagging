package de.js329.sportsvideotagging.controller

import de.js329.sportsvideotagging.database.EventDao
import de.js329.sportsvideotagging.database.EventJoinDao
import de.js329.sportsvideotagging.database.MatchDao
import de.js329.sportsvideotagging.database.TeamDao
import de.js329.sportsvideotagging.datamodels.*
import java.time.LocalDateTime
import java.time.ZoneOffset

class MatchTaggingController(
        private val matchDao: MatchDao,
        private val eventDao: EventDao,
        private val joinDao: EventJoinDao,
        private val teamDao: TeamDao
) {

    private var eventTypes: List<EventType> = ArrayList()
    var match: Match? = null
    var matchEvents: MutableList<MatchEvent> = ArrayList()
    var latestMatchEvent: MatchEvent? = null
    var eventOrderNum = 0

    suspend fun getTeamForName(teamName: String): Team {
        return teamDao.getTeamForName(teamName)
    }

    suspend fun getEventTypes(): List<EventType> {
        if (eventTypes.isEmpty()) {
            eventTypes = eventDao.getAllEventTypes()
        }
        return eventTypes
    }

    suspend fun getAllTeams(): List<Team> {
        return teamDao.getAll()
    }

    suspend fun startMatch(homeTeamId: Long, awayTeamId: Long, timestamp: Long) {
        match = Match(null, null, homeTeamId, awayTeamId, 0, 0)
        match?.let {
            val matchId = matchDao.insert(it)
            it.uid = matchId
            getEventTypes()
            eventTypes.first { eventType -> eventType.eventTitle == "Match Start" }.uid?.let { uid ->
                latestMatchEvent = MatchEvent(
                        null,
                        matchId,
                        eventOrderNum,
                        timestamp,
                        uid
                )
                addMatchEventToList()
            }
        }
    }

    fun createMatchEvent(eventType: EventType): Boolean {
        val matchId = match?.uid ?: return false
        val eventTypeId = eventType.uid ?: return false

        latestMatchEvent = MatchEvent(
                null,
                matchId,
                ++eventOrderNum,
                LocalDateTime.now().toEpochSecond(ZoneOffset.UTC),
                eventTypeId
        )
        return true
    }

    fun addEventAttributes(attributes: List<EventAttribute>, matchEvent: MatchEvent? = latestMatchEvent) {
        matchEvent?.let {
            val matchEventId = returnMatchEventId(it)
            attributes.forEach { attribute ->
                val attributeId = attribute.attributeId ?: return@forEach
                val eventAttributeJoin = MatchEventAttribute(matchEventId, attributeId)
                joinDao.insertAllEventAttributeJoins(eventAttributeJoin)
            }
        }
    }

    fun addEventPlayers(players: List<Player>, matchEvent: MatchEvent? = latestMatchEvent) {
        matchEvent?.let {
            val matchEventId = returnMatchEventId(it)
            players.forEach { player ->
                val playerId = player.playerId ?: return@forEach
                val eventPlayerJoin = MatchEventPlayer(matchEventId, playerId)
                joinDao.insertAllEventPlayerJoins(eventPlayerJoin)
            }
        }
    }

    fun addFollowUpEvent(eventType: EventType, players: List<Player> = ArrayList(), attributes: List<EventAttribute> = ArrayList()): Boolean {
        val matchId = match?.uid ?: return false
        val eventTypeId = eventType.uid ?: return false

        val followUpEvent = MatchEvent(
                null,
                matchId,
                ++eventOrderNum,
                LocalDateTime.now().toEpochSecond(ZoneOffset.UTC),
                eventTypeId
        )

        if (players.isNotEmpty()) {
            addEventPlayers(players, followUpEvent)
        }

        if (attributes.isNotEmpty()) {
            addEventAttributes(attributes, followUpEvent)
        }

        val followUpMatchId = returnMatchEventId(followUpEvent)
        latestMatchEvent?.followingEventId = followUpMatchId

        return true
    }

    fun addMatchEventToList() {
        val matchEvent = latestMatchEvent ?: return
        matchEvents.add(matchEvent)
        latestMatchEvent = null
    }

    fun endMatch(homeTeamScore: Int, awayTeamScore: Int) {
        match?.homeScore = homeTeamScore
        match?.awayScore = awayTeamScore
        match?.let { matchDao.updateAll(it) }
    }

    private fun returnMatchEventId(matchEvent: MatchEvent): Long {
        matchEvent.matchEventId?.let { return it }
        val autoGeneratedId = eventDao.insert(matchEvent)
        matchEvent.matchEventId = autoGeneratedId
        return autoGeneratedId
    }
}