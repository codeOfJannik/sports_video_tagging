package de.js329.sportsvideotagging.controller

import de.js329.sportsvideotagging.database.EventDao
import de.js329.sportsvideotagging.database.EventJoinDao
import de.js329.sportsvideotagging.database.MatchDao
import de.js329.sportsvideotagging.datamodels.*
import java.time.LocalDateTime
import java.time.ZoneOffset

class MatchTaggingController(
        homeTeamId: Long,
        awayTeamId: Long,
        private val eventTypes: List<EventType>,
        private val matchDao: MatchDao,
        private val eventDao: EventDao,
        private val joinDao: EventJoinDao
) {

    var match = Match(null, null, homeTeamId, awayTeamId, 0, 0)
    var matchEvents: MutableList<MatchEvent> = ArrayList()
    var latestMatchEvent: MatchEvent? = null
    var eventOrderNum = 0

    fun startMatch() {
        val matchId = matchDao.insert(match)
        match.uid = matchId
        eventTypes.first { eventType -> eventType.eventTitle == "Match Start" }.uid?.let { uid ->
            latestMatchEvent = MatchEvent(
                    null,
                    matchId,
                    eventOrderNum,
                    LocalDateTime.now().toEpochSecond(ZoneOffset.UTC),
                    uid
            )
            addMatchEventToList()
        }
    }

    fun createMatchEvent(eventType: EventType): Boolean {
        val matchId = match.uid ?: return false
        val eventTypeId = eventType.uid ?: return false

        latestMatchEvent = MatchEvent(
                null,
                matchId,
                ++eventOrderNum,
                LocalDateTime.now().toEpochSecond(ZoneOffset.UTC),
                eventTypeId
        )
        return true
    }

    fun addEventAttributes(attributes: List<EventAttribute>, matchEvent: MatchEvent? = latestMatchEvent) {
        matchEvent?.let {
            val matchEventId = returnMatchEventId(it)
            attributes.forEach { attribute ->
                val attributeId = attribute.attributeId ?: return@forEach
                val eventAttributeJoin = MatchEventAttribute(matchEventId, attributeId)
                joinDao.insertAllEventAttributeJoins(eventAttributeJoin)
            }
        }
    }

    fun addEventPlayers(players: List<Player>, matchEvent: MatchEvent? = latestMatchEvent) {
        matchEvent?.let {
            val matchEventId = returnMatchEventId(it)
            players.forEach { player ->
                val playerId = player.playerId ?: return@forEach
                val eventPlayerJoin = MatchEventPlayer(matchEventId, playerId)
                joinDao.insertAllEventPlayerJoins(eventPlayerJoin)
            }
        }
    }

    fun addFollowUpEvent(eventType: EventType, players: List<Player> = ArrayList(), attributes: List<EventAttribute> = ArrayList()): Boolean {
        val matchId = match.uid ?: return false
        val eventTypeId = eventType.uid ?: return false

        val followUpEvent = MatchEvent(
                null,
                matchId,
                ++eventOrderNum,
                LocalDateTime.now().toEpochSecond(ZoneOffset.UTC),
                eventTypeId
        )

        if (players.isNotEmpty()) {
            addEventPlayers(players, followUpEvent)
        }

        if (attributes.isNotEmpty()) {
            addEventAttributes(attributes, followUpEvent)
        }

        val followUpMatchId = returnMatchEventId(followUpEvent)
        latestMatchEvent?.followingEventId = followUpMatchId

        return true
    }

    fun addMatchEventToList() {
        val matchEvent = latestMatchEvent ?: return
        matchEvents.add(matchEvent)
        latestMatchEvent = null
    }

    fun endMatch(homeTeamScore: Int, awayTeamScore: Int) {
        match.homeScore = homeTeamScore
        match.awayScore = awayTeamScore
        matchDao.updateAll(match)
    }

    private fun returnMatchEventId(matchEvent: MatchEvent): Long {
        matchEvent.matchEventId?.let { return it }
        val autoGeneratedId = eventDao.insertMatchEvent(matchEvent)
        matchEvent.matchEventId = autoGeneratedId
        return autoGeneratedId
    }
}